#include "pch.h"
#include "rtdoom.h"
#include "GLRenderer.h"

#include "glad/glad.h"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/type_ptr.hpp"

namespace rtdoom
{

const char* vertexShaderSource = "#version 330 core\n"
                                 "layout (location = 0) in vec3 aPos;\n"
                                 "layout (location = 1) in vec3 aTexCoord;\n"
                                 "layout (location = 2) in float aTexNo;\n"
                                 "layout (location = 3) in float aLight;\n"
                                 "out vec3 TexCoord;\n"
                                 "out float TexNo;\n"
                                 "out float Light;\n"
                                 "uniform mat4 view;\n"
                                 "uniform mat4 projection;\n"
                                 "void main()\n"
                                 "{\n"
                                 "   gl_Position = projection * view * vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
                                 "   TexCoord = aTexCoord;"
                                 "   TexNo = aTexNo;"
                                 "   Light = aLight;"
                                 "}\0";
const char* fragmentShaderSource = "#version 330 core\n"
                                   "out vec4 FragColor;\n"
                                   "in vec3 TexCoord;\n"
                                   "in float TexNo;\n"
                                   "in float Light;\n"
                                   "uniform sampler2DArray ourTexture[32];\n"
                                   "void main()\n"
                                   "{\n"
                                   "       FragColor = texture(ourTexture[int(TexNo)], TexCoord);\n"
                                   "       FragColor = FragColor * Light;\n"
                                   "       FragColor = FragColor * min(1.0f, (gl_FragCoord.w + 1.25f) / 5.0f);\n"
                                   "       FragColor.w = 1.0f;\n"
                                   "}\n\0";

void GLRenderer::LoadMap()
{
    if(!m_gameState.m_mapDef->HasGL())
    {
        throw std::runtime_error("No GL data found! Drop off a matching .gwa file with GL nodes (generated by glBSP) alongside the .wad.");
    }

    int q = 0;
    for(const auto& ss : m_gameState.m_mapDef->m_subSectors)
    {
        int ssStart = m_context.m_indices.size();
        for(const auto& segment : ss->segments)
        {
            const auto&              frontSector = segment->frontSide.sector;
            int                      textureUnit = 0, textureNo = 0;
            float                    lightness = frontSector.lightLevel;
            std::shared_ptr<Texture> wtex;
            // auto-shade 90-degree edges
            if(segment->isVertical)
            {
                lightness *= 1.1f;
            }
            else if(segment->isHorizontal)
            {
                lightness *= 0.9f;
            }
            if(segment->isSolid)
            {
                wtex                  = m_context.AllocateTexture(segment->frontSide.middleTexture, textureUnit, textureNo);
                const auto texXOffset = (segment->xOffset + segment->frontSide.xOffset) / (float)wtex->width;
                const auto texYOffset = (segment->frontSide.yOffset) / (float)wtex->height;
                const auto segW       = Projection::Distance(segment->s, segment->e) / (float)wtex->width;
                const auto segH       = (frontSector.ceilingHeight - frontSector.floorHeight) / (float)wtex->height;

                m_context.AddWallSegment(segment->s.x,
                                         segment->s.y,
                                         frontSector.floorHeight,
                                         segment->e.x,
                                         segment->e.y,
                                         frontSector.ceilingHeight,
                                         texXOffset,
                                         texYOffset + segH,
                                         texXOffset + segW,
                                         texYOffset,
                                         textureUnit,
                                         textureNo,
                                         lightness);
            }
            else
            {
                const auto& backSector = segment->backSide.sector;

                if(segment->frontSide.lowerTexture != "-" && segment->frontSide.lowerTexture != "")
                {
                    wtex                  = m_context.AllocateTexture(segment->frontSide.lowerTexture, textureUnit, textureNo);
                    const auto texXOffset = (segment->xOffset + segment->frontSide.xOffset) / (float)wtex->width;
                    auto       texYOffset = (segment->frontSide.yOffset) / (float)wtex->height;
                    const auto segW       = Projection::Distance(segment->s, segment->e) / (float)wtex->width;
                    const auto segH       = abs(frontSector.floorHeight - backSector.floorHeight) / (float)wtex->height;

                    if(segment->lowerUnpegged)
                    {
                        // peg to ceiling
                        texYOffset += (frontSector.ceilingHeight - backSector.floorHeight) / (float)wtex->height;
                    }

                    m_context.AddWallSegment(segment->s.x,
                                             segment->s.y,
                                             frontSector.floorHeight,
                                             segment->e.x,
                                             segment->e.y,
                                             backSector.floorHeight,
                                             texXOffset,
                                             texYOffset + segH,
                                             texXOffset + segW,
                                             texYOffset,
                                             textureUnit,
                                             textureNo,
                                             lightness);
                }

                if(segment->frontSide.upperTexture != "-" && segment->frontSide.lowerTexture != "" && !segment->backSide.sector.isSky)
                {
                    wtex                  = m_context.AllocateTexture(segment->frontSide.upperTexture, textureUnit, textureNo);
                    const auto texXOffset = (segment->xOffset + segment->frontSide.xOffset) / (float)wtex->width;
                    auto       texYOffset = (segment->frontSide.yOffset) / (float)wtex->height;
                    const auto segW       = Projection::Distance(segment->s, segment->e) / (float)wtex->width;
                    const auto segH       = abs(backSector.ceilingHeight - frontSector.ceilingHeight) / (float)wtex->height;

                    if(segment->upperUnpegged)
                    {
                        // peg to ceiling - not tested
                        texYOffset += (frontSector.ceilingHeight - backSector.floorHeight) / (float)wtex->height;
                    }

                    m_context.AddWallSegment(segment->s.x,
                                             segment->s.y,
                                             backSector.ceilingHeight,
                                             segment->e.x,
                                             segment->e.y,
                                             frontSector.ceilingHeight,
                                             texXOffset,
                                             texYOffset + segH,
                                             texXOffset + segW,
                                             texYOffset,
                                             textureUnit,
                                             textureNo,
                                             lightness);
                }
            }
        }

        const auto& sector = m_gameState.m_mapDef->m_sectors[ss->sectorId];
        if(ss->segments.size())
        {
            // add triangle fan
            auto   curr = ss->segments.begin();
            Vertex fanStart((*curr)->s);
            while(++curr != ss->segments.end())
            {
                std::shared_ptr<Texture> wtex;
                int                      textureUnit, textureNo;
                if(sector.floorTexture != "-")
                {
                    wtex = m_context.AllocateTexture(sector.floorTexture, textureUnit, textureNo);
                    m_context.AddFloorCeiling((*curr)->e.x,
                                              (*curr)->e.y,
                                              (*curr)->s.x,
                                              (*curr)->s.y,
                                              fanStart.x,
                                              fanStart.y,
                                              sector.floorHeight,
                                              wtex->width,
                                              wtex->height,
                                              textureUnit,
                                              textureNo,
                                              sector.lightLevel);
                }
                if(sector.ceilingTexture != "-" && !sector.isSky)
                {
                    wtex = m_context.AllocateTexture(sector.ceilingTexture, textureUnit, textureNo);
                    m_context.AddFloorCeiling(fanStart.x,
                                              fanStart.y,
                                              (*curr)->s.x,
                                              (*curr)->s.y,
                                              (*curr)->e.x,
                                              (*curr)->e.y,
                                              sector.ceilingHeight,
                                              wtex->width,
                                              wtex->height,
                                              textureUnit,
                                              textureNo,
                                              sector.lightLevel);
                }
            }
        }

        m_context.m_subSectorOffsets[ss->subSectorId] = std::make_pair(ssStart, m_context.m_indices.size() - ssStart);
    }

    m_context.BindMap();
}

GLRenderer::GLRenderer(const GameState& gameState, const WADFile& wadFile, int width, int height) :
    Renderer {gameState}, m_context {wadFile}, m_width {width}, m_height {height}
{ }

void GLRenderer::Resize(int width, int height)
{
    glViewport(0, 0, width, height);
    m_width  = width;
    m_height = height;
}

void GLRenderer::Reset()
{
    m_context.Reset();
}

// entry method for rendering a frame
void GLRenderer::RenderFrame()
{
    glClearColor(0.15f, 0.15f, 0.15f, 1.0f); // TODO: replace with skybox
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glm::mat4 viewMat       = glm::mat4(1.0f);
    viewMat                 = glm::rotate(viewMat, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    viewMat                 = glm::scale(viewMat, glm::vec3(0.001f, 0.001f, 0.001f));
    viewMat                 = glm::rotate(viewMat, -m_gameState.m_player.a + glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    viewMat                 = glm::translate(viewMat, glm::vec3(-m_gameState.m_player.x, -m_gameState.m_player.y, -m_gameState.m_player.z));
    glm::mat4 projectionMat = glm::perspective(glm::radians(53.75f) / 1.27f, 1.27f * m_width / (float)m_height, 0.01f, 100.0f);

    m_context.BindView(glm::value_ptr(viewMat), glm::value_ptr(projectionMat));

    RenderSegments();
}

void GLRenderer::RenderFrame(FrameBuffer& frameBuffer)
{
}

void GLRenderer::Initialize()
{
    if(!gladLoadGL())
    {
        printf("Error initializing GL!\n");
        abort();
    }

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);

    m_context.CompileShaders(vertexShaderSource, fragmentShaderSource);
}

void GLRenderer::RenderSegments() const
{
    // iterate through all segments (map lines) in visibility order returned by traversing the map's BSP tree
    for(const auto& ss : m_gameState.m_mapDef->GetSubSectorsToDraw(m_gameState.m_player))
    {
        const auto& subSec = m_context.m_subSectorOffsets.at(ss->subSectorId);
        glDrawElements(GL_TRIANGLES, subSec.second, GL_UNSIGNED_INT, (void*)(subSec.first * sizeof(int)));
    }
}

void GLRenderer::RenderOverlay() const
{
    // TODO: render HUD etc.
}
/*
Frame* GLRenderer::GetLastFrame() const
{
    return m_frame.get();
}
*/
GLRenderer::~GLRenderer() { }
} // namespace rtdoom
