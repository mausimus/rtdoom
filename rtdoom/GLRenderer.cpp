#include "pch.h"
#include "rtdoom.h"
#include "GLRenderer.h"
#include "Projection.h"

#pragma warning(disable : 4201)

#include "glad/glad.h"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/type_ptr.hpp"

namespace rtdoom
{

const char* s_vertexShaderSource = "#version 330 core\n"
                                 "layout (location = 0) in vec3 aPos;\n"
                                 "layout (location = 1) in vec3 aTexCoord;\n"
                                 "layout (location = 2) in float aTexNo;\n"
                                 "layout (location = 3) in float aLight;\n"
                                 "out vec3 TexCoord;\n"
                                 "out float TexNo;\n"
                                 "out float Light;\n"
                                 "uniform mat4 _view;\n"
                                 "uniform mat4 _projection;\n"
                                 "void main()\n"
                                 "{\n"
                                 "   gl_Position = _projection * _view * vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
                                 "   TexCoord = aTexCoord;"
                                 "   TexNo = aTexNo;"
                                 "   Light = aLight;"
                                 "}\0";

const char* s_fragmentShaderSource = "#version 330 core\n"
                                   "out vec4 FragColor;\n"
                                   "in vec3 TexCoord;\n"
                                   "in float TexNo;\n"
                                   "in float Light;\n"
                                   "uniform sampler2DArray _textures[32];\n"
                                   "void main()\n"
                                   "{\n"
                                   "       FragColor = texture(_textures[int(TexNo)], TexCoord);\n"
                                   "       FragColor = FragColor * Light;\n"
                                   "       FragColor = FragColor * min(1.0f, (gl_FragCoord.w + 1.25f) / 5.0f);\n"
                                   "       FragColor.w = 1.0f;\n"
                                   "}\0";

GLRenderer::GLRenderer(const GameState& gameState, const WADFile& wadFile, int width, int height) :
    RendererBase {gameState}, m_context {wadFile}, m_width {width}, m_height {height}
{ }

void GLRenderer::LoadMap()
{
    if(!m_gameState.m_mapDef->HasGL())
    {
        throw std::runtime_error("No GL data found! Drop off a matching .gwa file with GL nodes (generated by glBSP) alongside the .wad.");
    }

    for(const auto& subSector : m_gameState.m_mapDef->m_subSectors)
    {
        int startIndex = m_context.m_indices.size();
        for(const auto& segment : subSector->segments)
        {
            const auto&              frontSector = segment->frontSide.sector;
            int                      textureUnit = 0, textureNo = 0;
            float                    lightness = frontSector.lightLevel;
            std::shared_ptr<Texture> texture;
            // auto-shade 90-degree edges
            if(segment->isVertical)
            {
                lightness *= 1.1f;
            }
            else if(segment->isHorizontal)
            {
                lightness *= 0.9f;
            }
            if(segment->isSolid)
            {
                texture               = m_context.AllocateTexture(segment->frontSide.middleTexture, textureUnit, textureNo);
                const auto texXOffset = (segment->xOffset + segment->frontSide.xOffset) / (float)texture->width;
                const auto texYOffset = (segment->frontSide.yOffset) / (float)texture->height;
                const auto segW       = Projection::Distance(segment->s, segment->e) / (float)texture->width;
                const auto segH       = (frontSector.ceilingHeight - frontSector.floorHeight) / (float)texture->height;

                m_context.AddWallSegment(segment->s,
                                         frontSector.floorHeight,
                                         segment->e,
                                         frontSector.ceilingHeight,
                                         texXOffset,
                                         texYOffset + segH,
                                         texXOffset + segW,
                                         texYOffset,
                                         textureUnit,
                                         textureNo,
                                         lightness);
            }
            else
            {
                const auto& backSector = segment->backSide.sector;

                if(segment->frontSide.lowerTexture != "-" && segment->frontSide.lowerTexture != "")
                {
                    texture               = m_context.AllocateTexture(segment->frontSide.lowerTexture, textureUnit, textureNo);
                    const auto texXOffset = (segment->xOffset + segment->frontSide.xOffset) / (float)texture->width;
                    auto       texYOffset = (segment->frontSide.yOffset) / (float)texture->height;
                    const auto segW       = Projection::Distance(segment->s, segment->e) / (float)texture->width;
                    const auto segH       = abs(frontSector.floorHeight - backSector.floorHeight) / (float)texture->height;

                    if(segment->lowerUnpegged)
                    {
                        texYOffset += (frontSector.ceilingHeight - backSector.floorHeight) / (float)texture->height;
                    }

                    m_context.AddWallSegment(segment->s,
                                             frontSector.floorHeight,
                                             segment->e,
                                             backSector.floorHeight,
                                             texXOffset,
                                             texYOffset + segH,
                                             texXOffset + segW,
                                             texYOffset,
                                             textureUnit,
                                             textureNo,
                                             lightness);
                }

                if(segment->frontSide.upperTexture != "-" && segment->frontSide.lowerTexture != "" && !segment->backSide.sector.isSky)
                {
                    texture               = m_context.AllocateTexture(segment->frontSide.upperTexture, textureUnit, textureNo);
                    const auto texXOffset = (segment->xOffset + segment->frontSide.xOffset) / (float)texture->width;
                    auto       texYOffset = (segment->frontSide.yOffset) / (float)texture->height;
                    const auto segW       = Projection::Distance(segment->s, segment->e) / (float)texture->width;
                    const auto segH       = abs(backSector.ceilingHeight - frontSector.ceilingHeight) / (float)texture->height;

                    if(segment->upperUnpegged)
                    {
                        texYOffset += (frontSector.ceilingHeight - backSector.floorHeight) / (float)texture->height;
                    }

                    m_context.AddWallSegment(segment->s,
                                             backSector.ceilingHeight,
                                             segment->e,
                                             frontSector.ceilingHeight,
                                             texXOffset,
                                             texYOffset + segH,
                                             texXOffset + segW,
                                             texYOffset,
                                             textureUnit,
                                             textureNo,
                                             lightness);
                }
            }
        }

        const auto& sector = m_gameState.m_mapDef->m_sectors[subSector->sectorId];
        if(subSector->segments.size())
        {
            // create triangle fan from current (convex) subsector
            auto   curr = subSector->segments.begin();
            Vertex fanStart((*curr)->s);
            while(++curr != subSector->segments.end())
            {
                std::shared_ptr<Texture> texture;
                int                      textureUnit, textureNo;
                const auto&              fanLine = *curr;
                if(sector.floorTexture != "-")
                {
                    texture = m_context.AllocateTexture(sector.floorTexture, textureUnit, textureNo);
                    m_context.AddFloorCeiling(fanLine->e,
                                              fanLine->s,
                                              fanStart,
                                              sector.floorHeight,
                                              texture->width,
                                              texture->height,
                                              textureUnit,
                                              textureNo,
                                              sector.lightLevel);
                }
                if(sector.ceilingTexture != "-" && !sector.isSky)
                {
                    texture = m_context.AllocateTexture(sector.ceilingTexture, textureUnit, textureNo);
                    m_context.AddFloorCeiling(fanStart,
                                              fanLine->s,
                                              fanLine->e,
                                              sector.ceilingHeight,
                                              texture->width,
                                              texture->height,
                                              textureUnit,
                                              textureNo,
                                              sector.lightLevel);
                }
            }
        }

        m_context.m_subSectorOffsets[subSector->subSectorId] = std::make_pair(startIndex, m_context.m_indices.size() - startIndex);
    }

    m_context.BindMap();
}

void GLRenderer::Resize(int width, int height)
{
    glViewport(0, 0, width, height);
    m_width  = width;
    m_height = height;
}

void GLRenderer::Reset()
{
    m_context.Reset();
}

void GLRenderer::RenderFrame()
{
    glClearColor(0.15f, 0.15f, 0.15f, 1.0f); // TODO: replace with skybox
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glm::mat4 viewMat       = glm::mat4(1.0f);
    viewMat                 = glm::rotate(viewMat, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    viewMat                 = glm::scale(viewMat, glm::vec3(0.001f, 0.001f, 0.001f));
    viewMat                 = glm::rotate(viewMat, -m_gameState.m_player.a + glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    viewMat                 = glm::translate(viewMat, glm::vec3(-m_gameState.m_player.x, -m_gameState.m_player.y, -m_gameState.m_player.z));
    glm::mat4 projectionMat = glm::perspective(glm::radians(53.75f) / 1.27f, 1.27f * m_width / (float)m_height, 0.01f, 100.0f);

    m_context.BindView(glm::value_ptr(viewMat), glm::value_ptr(projectionMat));

    RenderSegments();
}

void GLRenderer::Initialize()
{
    if(!gladLoadGL())
    {
        printf("Error initializing GL!\n");
        abort();
    }

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);

    m_context.Initialize();
    m_context.CompileShaders(s_vertexShaderSource, s_fragmentShaderSource);
}

void GLRenderer::RenderSegments() const
{
    // iterate through all segments (map lines) in visibility order returned by traversing the map's BSP tree
    for(const auto& ss : m_gameState.m_mapDef->GetSubSectorsToDraw(m_gameState.m_player))
    {
        const auto& subSec = m_context.m_subSectorOffsets.at(ss->subSectorId);
        glDrawElements(GL_TRIANGLES, subSec.second, GL_UNSIGNED_INT, (void*)(subSec.first * sizeof(int)));
    }
}

GLRenderer::~GLRenderer() { }
} // namespace rtdoom
